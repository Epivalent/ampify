#! /usr/bin/env python

# Copyright (c) 2009 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Changes released into the Public Domain by tav <tav@espians.com>

import os
import re
import subprocess
import sys

# ------------------------------------------------------------------------------
# extend sys.path dynamically
# ------------------------------------------------------------------------------

def DieWithError(message):
  print >>sys.stderr, message
  sys.exit(1)


def RunCommand(cmd, error_ok=False, error_message=None, exit_code=False,
               redirect_stdout=True):
  # Useful for debugging:
  # print >>sys.stderr, ' '.join(cmd)
  if redirect_stdout:
    stdout = subprocess.PIPE
  else:
    stdout = None
  proc = subprocess.Popen(cmd, stdout=stdout)
  output = proc.communicate()[0]
  if exit_code:
    return proc.returncode
  if not error_ok and proc.returncode != 0:
    DieWithError('Command "%s" failed.\n' % (' '.join(cmd)) +
                 (error_message or output))
  return output

sys.path.insert(0, RunCommand(['git', 'cl', '--root']).strip())

# ------------------------------------------------------------------------------
# local imports
# ------------------------------------------------------------------------------

import presubmit_support
import scm
import watchlists

from git_cl import Changelist


def Backquote(cmd, cwd=None):
  """Like running `cmd` in a shell script."""
  return subprocess.Popen(cmd,
                          cwd=cwd,
                          stdout=subprocess.PIPE).communicate()[0].strip()


class ChangeOptions:
  def __init__(self, commit=None, upstream_branch=None):
    self.commit = commit
    self.verbose = None
    self.default_presubmit = None
    self.may_prompt = None

    root = Backquote(['git', 'rev-parse', '--show-cdup'])
    if not root:
      root = "."
    absroot = os.path.abspath(root)
    if not root:
      raise Exception("Could not get root directory.")
    log = Backquote(['git', 'show', '--name-only',
                     '--pretty=format:%H%n%s%n%n%b'])
    m = re.match(r'^(\w+)\n(.*)$', log, re.MULTILINE|re.DOTALL)
    if not m:
      raise Exception("Could not parse log message: %s" % log)
    name = m.group(1)
    files = scm.GIT.CaptureStatus([root], upstream_branch)
    issue = Backquote(['git', 'cl', 'status', '--field=id'])
    if issue == 'None':
      issue = ''
    try:
      description = Changelist().GetDescription() or m.group(2)
    except ValueError:
      description = m.group(2)
    patchset = None
    self.change = presubmit_support.GitChange(name, description, absroot, files,
                                              issue, patchset)


def RunHooks(hook_name, upstream_branch):
  commit = (hook_name == 'pre-cl-push')

  # Create our options based on the command-line args and the current checkout.
  options = ChangeOptions(commit=commit, upstream_branch=upstream_branch)

  # Apply watchlists on upload.
  if not commit:
    watchlist = watchlists.Watchlists(options.change.RepositoryRoot())
    files = [f.LocalPath() for f in options.change.AffectedFiles()]
    watchers = watchlist.GetWatchersForPaths(files)
    Backquote(['git', 'config', '--replace-all',
               'codereview.extracc', ','.join(watchers)])

  # Run the presubmit checks.
  if presubmit_support.DoPresubmitChecks(options.change,
                                         options.commit,
                                         options.verbose,
                                         sys.stdout,
                                         sys.stdin,
                                         options.default_presubmit,
                                         options.may_prompt):
    sys.exit(0)
  else:
    sys.exit(1)


if __name__ == '__main__':
  program_name = os.path.basename(sys.argv[0])
  if len(sys.argv) != 2:
    print "Usage: %s [upstream branch]" % program_name
    sys.exit(1)
  RunHooks(program_name, sys.argv[1])

